<!DOCTYPE html>
<html>
<head>
<title>Blind Obstacle Detector</title>
<style>
    body {
        background: #000;
        color: #fff;
        font-family: Arial;
        text-align: center;
    }
    video, canvas { display:none; }
    #status { margin-top: 30px; font-size: 22px; }
</style>
</head>

<body>
<h2>Blind Obstacle Detector</h2>
<div id="status">Starting cameraâ€¦</div>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script>
// -----------------------------------------------------------
// Text-to-speech
// -----------------------------------------------------------
function say(msg){
    const u = new SpeechSynthesisUtterance(msg);
    speechSynthesis.speak(u);
}

// -----------------------------------------------------------
// Beeper
// -----------------------------------------------------------
function beep(rate){
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.frequency.value = 700;
    gain.gain.value = 0.2;
    osc.connect(gain);
    gain.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.1);
}

// -----------------------------------------------------------
// Camera setup
// -----------------------------------------------------------
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let prevFrame = null;

navigator.mediaDevices.getUserMedia({ video: true })
.then(stream => {
    video.srcObject = stream;
    video.onloadedmetadata = () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        say("Camera started. Ready.");
        document.getElementById("status").innerText = "Camera Ready";
        requestAnimationFrame(processFrame);
    };
})
.catch(err => { alert("Camera error: " + err); });

// -----------------------------------------------------------
// Utility functions
// -----------------------------------------------------------
function avgBrightness(data){
    let sum = 0;
    for (let i = 0; i < data.length; i += 4){
        sum += (data[i] + data[i+1] + data[i+2]) / 3;
    }
    return sum / (data.length / 4);
}

function edgeStrength(data){
    let sum = 0;
    for (let i = 0; i < data.length; i += 4){
        const lum = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
        sum += lum;
    }
    return sum / (data.length / 4);
}

// difference % between two frames
function diffPercent(a, b){
    let diff = 0;
    for (let i = 0; i < a.length; i += 4){
        diff += Math.abs(a[i] - b[i]);
        diff += Math.abs(a[i+1] - b[i+1]);
        diff += Math.abs(a[i+2] - b[i+2]);
    }
    return diff / (a.length * 3);
}

// -----------------------------------------------------------
// Main logic variables
// -----------------------------------------------------------
let stableCount = 0;
const REQUIRED_STABILITY = 3;
let lastArea = 0;
let approachCounter = 0;

// -----------------------------------------------------------
// Frame loop
// -----------------------------------------------------------
function processFrame(){

    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const frame = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = frame.data;

    // brightness for auto sensitivity
    const bright = avgBrightness(data);
    let sensitivity = bright < 40 ? 0.01 : bright < 80 ? 0.02 : 0.03;

    // edge detection baseline
    const currentEdge = edgeStrength(data);

    if (prevFrame){
        const diff = diffPercent(data, prevFrame.data);

        // is there motion?
        const motionDetected = diff > sensitivity;

        // region detection
        const third = data.length / 3;
        const leftDiff = diffPercent(
            data.slice(0, third),
            prevFrame.data.slice(0, third)
        );
        const centerDiff = diffPercent(
            data.slice(third, 2*third),
            prevFrame.data.slice(third, 2*third)
        );
        const rightDiff = diffPercent(
            data.slice(2*third),
            prevFrame.data.slice(2*third)
        );

        // obstacle confirmed by motion + edges
        const edgeDetected = currentEdge > 40; // rough threshold
        let obstacle = motionDetected && edgeDetected;

        if (obstacle){

            // Stability filter: must be stable across frames
            stableCount++;
            if (stableCount >= REQUIRED_STABILITY){

                // Depth approximation
                let area = diff * 100;
                if (area > lastArea + 0.5) {
                    approachCounter++;
                    if (approachCounter > 2){
                        say("Object approaching. Stop");
                        navigator.vibrate([200,100,200]);
                        beep(150);
                        approachCounter = 0;
                    }
                }
                lastArea = area;

                // Direction detection
                if (centerDiff > sensitivity){
                    say("Object ahead");
                } else if (leftDiff > sensitivity){
                    say("Object left");
                } else if (rightDiff > sensitivity){
                    say("Object right");
                }

                // Proximity beep (parking sensor)
                if (area > 20) beep(200);
                else if (area > 10) beep(350);

                stableCount = 0;
            }
        } else {
            stableCount = 0;
        }
    }

    prevFrame = frame;

    // Slower loop (saves battery + more stable)
    setTimeout(() => requestAnimationFrame(processFrame), 120);
}

</script>
</body>
</html>